<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://kunmonster.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://kunmonster.github.io//" rel="alternate" type="text/html" hreflang="en" /><updated>2025-04-11T20:30:53+08:00</updated><id>https://kunmonster.github.io//feed.xml</id><title type="html">kkmonster</title><subtitle>生命中有万事的可能</subtitle><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><entry><title type="html">使用SV完成主成分分析</title><link href="https://kunmonster.github.io//2025/04/11/%E4%BD%BF%E7%94%A8SV%E5%AE%8C%E6%88%90%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/" rel="alternate" type="text/html" title="使用SV完成主成分分析" /><published>2025-04-11T20:30:00+08:00</published><updated>2025-04-11T20:30:00+08:00</updated><id>https://kunmonster.github.io//2025/04/11/%E4%BD%BF%E7%94%A8SV%E5%AE%8C%E6%88%90%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90</id><content type="html" xml:base="https://kunmonster.github.io//2025/04/11/%E4%BD%BF%E7%94%A8SV%E5%AE%8C%E6%88%90%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"><![CDATA[<p>主成分分析(Principal component analysis)是一种降维的方法， 将高维特征映射到低维空间，也就是如果一个记录有很多特征，那么我们需要找到一组更少的特征来表示这众多的特征，这些更少的特征就称为主成分。</p>

<p>在群体基因组中，我们经常使用PCA来查看群体间的关系，以及群体内分层的现象等，大部分时间都是使用SNP来进行分析，也就是各群体间共有的SNP位点，对他们的基因型进行主成分分析。</p>

<p>本文将使用结构变异(Structural variation)进行主成分分析。</p>

<h2 id="数据准备">数据准备</h2>
<hr />

<p>在进行主成分分析之前，我们需要准备一个VCF文件，其中包含每个变异的相关信息，以及每个样本的基因型信息。</p>

<p>这里有个小坑，我的结构变异是分群体进行calling的，需要先得到群体间的公共位点才行，但是结构变异的断点本身就是不准确的，所以这一步还是很困难的。</p>

<p>我的处理步骤如下：</p>

<ol>
  <li>提取每个群体的位点</li>
</ol>

<p>对每个群体提取所有变异位点，包含染色体号和变异起始位置</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bcftools query <span class="nt">-f</span> <span class="s1">'%CHROM\t%POS\n'</span> your_vcf_file_1 | <span class="nb">sort</span> <span class="nt">-V</span> <span class="nt">-k1</span>,1 <span class="nt">-k2</span>,2n <span class="o">&gt;</span> site1.list
bcftools query <span class="nt">-f</span> <span class="s1">'%CHROM\t%POS\n'</span> your_vcf_file_2 | <span class="nb">sort</span> <span class="nt">-V</span> <span class="nt">-k1</span>,1 <span class="nt">-k2</span>,2n <span class="o">&gt;</span> site2.list
bcftools query <span class="nt">-f</span> <span class="s1">'%CHROM\t%POS\n'</span> your_vcf_file_3 | <span class="nb">sort</span> <span class="nt">-V</span> <span class="nt">-k1</span>,1 <span class="nt">-k2</span>,2n <span class="o">&gt;</span> site3.list
</code></pre></div></div>

<p><em>注意：上面命令中sort -V是按自然顺序排序，如果你文件中的染色体名是有英文字母的，如NCBI的NCxxxxx那么可以使用，如果你的染色体名字直接是数字那么就不需要加该选项</em></p>

<ol>
  <li>计算群体的共有位点</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">awk</span> <span class="s1">'NR==FNR {pos[$0]; next} ($0 in pos)'</span> site1.list site2.list site3.list <span class="o">&gt;</span> common.list

</code></pre></div></div>

<ol>
  <li>提取每个群体共有位点的变异</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
bcftools view <span class="nt">-T</span> common.list <span class="nt">-O</span> z <span class="nt">-o</span> population_1.vcf.gz vcf_1
bcftools view <span class="nt">-T</span> common.list <span class="nt">-O</span> z <span class="nt">-o</span> population_2.vcf.gz vcf_2
bcftools view <span class="nt">-T</span> common.list <span class="nt">-O</span> z <span class="nt">-o</span> population_3.vcf.gz vcf_3

</code></pre></div></div>

<ol>
  <li>使用bcftools进行合并（同时使用bcftools计算出AF,MAF,MISSING RATE）</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
bcftools merge population_1.vcf.gz population_2.vcf.gz population_3.vcf.gz <span class="nt">-O</span> z <span class="nt">-o</span> common_var.vcf.gz

bcftools +fill-tags common_var.vcf.gz <span class="nt">--</span> <span class="nt">-t</span> AF | bcftools +fill-tags <span class="nt">--</span> <span class="nt">-t</span> MAF | bcftools +fill-tags <span class="nt">-O</span> z <span class="nt">-o</span> common_var_with_info.vcf.gz <span class="nt">--</span> <span class="nt">-t</span> F_MISSING

</code></pre></div></div>

<ol>
  <li>将vcf文件中的ALT字段全部替换成PLINK可接受的输入</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># 此处假设vcf文件中ALT字段为&lt;xxxxx&gt;类型</span>
<span class="c"># 使用sed替换</span>

bcftools view common_var_with_info.vcf.gz | <span class="nb">sed</span> <span class="nt">-E</span> <span class="s1">'/^#/! s/&lt;[^&gt;]+&gt;/SV/g'</span> <span class="o">&gt;</span> common_var_with_info.vcf

bgzip common_var_with_info.vcf
tabix common_var_with_info.vcf.gz

</code></pre></div></div>

<ol>
  <li>将vcf文件转换成PLINK的标准输入（使用PLINK2）</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plink2 <span class="nt">--vcf</span> common_var_with_info.vcf.gz <span class="se">\</span>
<span class="nt">--geno</span> 0.05 <span class="se">\ </span>  <span class="c"># 每个变异的missing rate &lt; 5%</span>
<span class="nt">--maf</span> 0.05 <span class="se">\ </span>   <span class="c"># 每个变异maf &gt; 0.05</span>
<span class="nt">--hwe</span> 1e-6 <span class="se">\ </span>   <span class="c"># 满足哈代温伯格平衡</span>
<span class="nt">--freq</span> <span class="se">\ </span>       <span class="c"># 加载基因型频率</span>
<span class="nt">--allow-extra-chr</span> <span class="se">\ </span><span class="c"># 由于我使用NCBI refseq的染色体ID,所以加上该选项,如果是数字染色体名则不需要</span>
<span class="nt">--make-bed</span> <span class="se">\</span>
<span class="nt">--out</span> plink/plink_input <span class="c"># 将结果存放到plink目录下,结果文件以plink_input为前缀</span>
</code></pre></div></div>

<h2 id="主成分分析及可视化">主成分分析及可视化</h2>
<hr />

<p>在将数据转换成PLINK标准输入后，使用PLINK继续进行主成分分析，并且使用R以及ggplot2包进行可视化。</p>

<ol>
  <li>计算主成分</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plink2 <span class="nt">--bfile</span> plink_input <span class="nt">--pca</span> 10 <span class="nt">-out</span> pca_res

</code></pre></div></div>

<p>计算主成分后将会获得两个文件</p>

<ul>
  <li>pca_res.eigenval （每个主成分的比例，无表头）</li>
  <li>pca_res.eigenvec（样本为行，主成分为列，有表头）</li>
</ul>

<ol>
  <li>进行可视化</li>
</ol>

<p>将上述两个文件，使用R打开，注意，我这里有三个群体，还需要手动在pca_res.eigenvec中加一下群体信息</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eigenvec</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s1">'pca_res.eigenvec'</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="n">sep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"\t"</span><span class="p">)</span><span class="w">

</span><span class="n">eigenval</span><span class="o">&lt;-</span><span class="n">read.table</span><span class="p">(</span><span class="s2">"pca_res.eigenval"</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">



</span><span class="c1"># 去掉第一列并加上分组信息</span><span class="w">

</span><span class="n">library</span><span class="p">(</span><span class="n">dplyr</span><span class="p">)</span><span class="w">
</span><span class="n">eigenvec</span><span class="o">&lt;-</span><span class="n">mutate</span><span class="p">(</span><span class="n">eigenvec</span><span class="p">[</span><span class="m">-1</span><span class="p">],</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substr</span><span class="p">(</span><span class="n">IID</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">))</span><span class="w">

</span><span class="n">pca_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="w">
  </span><span class="n">Sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eigenvec</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="c1"># 第一列样本信息</span><span class="w">
  </span><span class="n">Group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factor</span><span class="p">(</span><span class="n">eigenvec</span><span class="o">$</span><span class="n">group</span><span class="p">),</span><span class="w">
  </span><span class="n">PC1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eigenvec</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="c1"># 主成分1</span><span class="w">
  </span><span class="n">PC2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eigenvec</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w">  </span><span class="c1"># 主成分2</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="c1"># 计算方差解释比例</span><span class="w">
</span><span class="n">var_explained</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">eigenval</span><span class="o">$</span><span class="n">V1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">eigenval</span><span class="o">$</span><span class="n">V1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">100</span><span class="w">

</span><span class="n">library</span><span class="p">(</span><span class="s1">'ggplot2'</span><span class="p">)</span><span class="w">
</span><span class="c1"># 绘制PCA图</span><span class="w">
</span><span class="n">ggplot</span><span class="p">(</span><span class="n">pca_data</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PC1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PC2</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Group</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_point</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.7</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">labs</span><span class="p">(</span><span class="w">
    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="s2">"PC1 ("</span><span class="p">,</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">var_explained</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="s2">"%)"</span><span class="p">),</span><span class="w">
    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="s2">"PC2 ("</span><span class="p">,</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">var_explained</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="s2">"%)"</span><span class="p">),</span><span class="w">

  </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">stat_ellipse</span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.95</span><span class="p">,</span><span class="w"> </span><span class="n">linetype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="c1"># 添加95%置信椭圆</span><span class="w">
  </span><span class="n">theme_bw</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="w">
    </span><span class="n">legend.position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"top"</span><span class="p">,</span><span class="w">
    </span><span class="n">plot.title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_text</span><span class="p">(</span><span class="n">hjust</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>然后就会得到如下PCA图</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202504012006653.png" alt="image.png" /></p>

<h2 id="最后">最后</h2>
<hr />

<p>使用结构变异来做PCA分析还是有很多小坑，特别是PLINK对SV支持不是很好，ALT列不能识别，需要手动替换</p>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="SV" /><category term="PCA" /><summary type="html"><![CDATA[主成分分析(Principal component analysis)是一种降维的方法， 将高维特征映射到低维空间，也就是如果一个记录有很多特征，那么我们需要找到一组更少的特征来表示这众多的特征，这些更少的特征就称为主成分。]]></summary></entry><entry><title type="html">DeepsvFilter:基于深度学习完成结果变异过滤</title><link href="https://kunmonster.github.io//2025/03/16/DeepsvFilter-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E7%BB%93%E6%9E%9C%E5%8F%98%E5%BC%82%E8%BF%87%E6%BB%A4/" rel="alternate" type="text/html" title="DeepsvFilter:基于深度学习完成结果变异过滤" /><published>2025-03-16T17:11:00+08:00</published><updated>2025-03-16T17:11:00+08:00</updated><id>https://kunmonster.github.io//2025/03/16/DeepsvFilter:%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E7%BB%93%E6%9E%9C%E5%8F%98%E5%BC%82%E8%BF%87%E6%BB%A4</id><content type="html" xml:base="https://kunmonster.github.io//2025/03/16/DeepsvFilter-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E7%BB%93%E6%9E%9C%E5%8F%98%E5%BC%82%E8%BF%87%E6%BB%A4/"><![CDATA[<p>最近在做基因组结构变异相关工作，阅读相关论文，这篇论文就是关于基因组结构变异的，主要用于从寻找出的结构变异中去除假阳性结果，获取真实结构变异。</p>

<h2 id="introduction">Introduction</h2>
<hr />
<p>发表期刊：Briefings in Bioinformatics
发表时间：2021年
作者：Yongzhuang liu等
原文链接：<a href="https://doi.org/10.1093/bib/bbaa370">A deep learning approach for filtering structural variants in short read sequencing data</a></p>

<p>摘要</p>

<blockquote>
  <p>随着基因组测序数据的成本下降、越来越多的测序数据用于基因组研究包括基因组结构变异研究，在人类基因组中广泛应用，但是由于二代重测序数据的局限性，假阳性的结果很多，所以需要合适的变异过滤措施来保证变异的准确性。</p>
</blockquote>

<h2 id="研究背景">研究背景</h2>
<hr />

<ol>
  <li>二代测序的固有缺点导致结构变异检测结果中假阳性数量居高不下</li>
  <li>过滤假阳性变异的参数难以指定，不同数据集有不同的特征，所以每个数据集的过滤参数难以指定</li>
  <li>手动将bam文件可视化并查看结构变异区域bam文件支持度的方式效率太低，并且全基因组范围一般有成千上万个结构变异，手动查看比对文件太慢</li>
  <li>监督学习方法已经广泛应用于检测基因组或外显子变异，多数工具都将该类任务转换成分类任务，使用神经网络来解决</li>
</ol>

<ul>
  <li>作者列举了一些使用深度学习来解决基因组变异问题的例子</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">软件</th>
      <th style="text-align: center">解决问题</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">forestSV,SV</td>
      <td style="text-align: center">使用read alignment通过随机森林和支持向量机检测SV</td>
    </tr>
    <tr>
      <td style="text-align: center">DeepVariant</td>
      <td style="text-align: center">使用read alignment 通过将比对和相关信息encode成图片使用神经网络检测Indels,SNVs</td>
    </tr>
    <tr>
      <td style="text-align: center">CNNScore Variants</td>
      <td style="text-align: center">使用神经网络过滤SNP,INDEL</td>
    </tr>
    <tr>
      <td style="text-align: center">Clairvoyant</td>
      <td style="text-align: center">将SNVs和INDELs的检测转化成多分类任务</td>
    </tr>
  </tbody>
</table>

<h2 id="核心问题提取">核心问题提取</h2>
<hr />
<p>从简介中可以了解到，此文章重点在于基因组结构变异的过滤，通过对背景以及简介部分的精炼大概可以提取出以下关键问题</p>

<ol>
  <li>
    <p>怎么将SVs的过滤转换成分类问题？</p>
  </li>
  <li>
    <p>怎么获取高质量的训练数据？</p>
  </li>
  <li>
    <p>怎么将变异数据编码成适合神经网络训练的数据？</p>
  </li>
  <li>
    <p>选用什么样的模型？</p>
  </li>
</ol>

<h2 id="思路方法">思路方法</h2>

<hr />

<p>作者仅考虑100bp以上的结构变异，因为50～100bp的变异对于二代测序数据来说，还是能准确的检测出来的。并且其选择将不同的变异类型分开，这样做也有一定道理，不同变异类型肯定有不同的特征，分开来提取特征或许更好，如果一起来提取那么获取到的特征可能没那么准确。</p>

<h3 id="数据准备">数据准备</h3>

<ul>
  <li>训练数据的获取</li>
</ul>

<p>该研究使用GIAB的HG002样本的60X WGS数据（已经使用NovoAlign 比对到hs37d5）以及 NA12878 （50X） 作为训练数据，其使用Lumpy,Delly,Manta分别对该样本检测结构变异（排除着丝粒和中心粒区域），如果使用这三种工具找到的结构变异与GIAB中的某个变异有90%以上的重叠，那么就列为Positive样本，否则列为Negative样本，随后将每个SV断点编码成一张3通道的图片，具体方法后述，将这些标记图片的90%用于训练，10%用于验证。</p>

<ul>
  <li>预测数据</li>
</ul>

<p>与准备训练数据一致，使用三种不同的工具检测变异，对于DELs,DUPs,INVs,如果三个工具的结果中有90%以上的相互重叠那么当成一个变异，对于INS，如果三个结果中某一个INS他们的断点在上下游100bp内，那么当成同一个变异，然后生成SV image，交给训练好的模型进行预测。</p>

<ul>
  <li>SV图片生成</li>
</ul>

<p>对于非INS类型变异，其将两个断点扩展成两个范围 ： $[x-\alpha , x+\alpha]$ , $[y - \alpha,y + \alpha]$ , 其中 $\alpha$ 是模型超参数下，对于不同的模型，设置为149或者112；对于INS类型变异，因为只有一个“断点”，那么只对该点进行上述操作。</p>

<p>对于每个断点，提取上述范围内的RD（Read depth）,SR（Split Reads）,DRP（discordant reads pairs）的信息形成三个通道，并且限制每个位点覆盖的reads数目不超过149,112,那么每个图片的形状为 $299 * 149$ 或者 $224 * 112$。 这个形状怎么来的呢，即以断点为中心，上下游指定范围内，覆盖这个范围的reads的三种信息将会被编码，每行对应一个reads。</p>

<p>针对RD通道，如果位点被某reads覆盖，那么该像素填充为255，如果没被覆盖则填充0</p>

<p>针对SR通道，如果该位点在某个Reads发生split read，那么填充为255，反之为0</p>

<p>针对DRP通道，如果该位点的reads被标记为discordant那么填充255，反之为0（该研究对discordant有具体描述，见原文Method部分）</p>

<p>如果一个断点的范围覆盖了配对的另一个断点，那么对这两个断点仍然生成两张图像。忽略掉左断点中覆盖了右断点的SRs和DRPs，同理右断点忽略左断点的SRs和DRPs。最后将DRPs和SRs信息放在图像顶部 ？（疑惑中……）</p>

<p>完成一个SV的两张图片的生成后，在垂直方向上将两张图concat起来，形成一张，表示该SV。</p>

<ul>
  <li>数据增强</li>
</ul>

<p>作者对typical true sv(样本中左右断点的距离和ground truth set中左右断点的距离不超过158bp) ， Typical false sv(与前者相反，超过了158bp)进行数据增强（水平翻转，垂直翻转）以扩展训练数据集。</p>

<p>真正准备训练数据时，只准备了DEL,DUP类型数据，并且分开准备的，DEL类型直接使用上述方法，取工具与GIAB中重合的部分，但是DUP类型，直接使用两个工具都得出的相同位点为POSTIVE SV（个人绝对不妥，但是迫于没有ground truth data）</p>

<p>最后90%的图片用于训练，10%的图片用于训练时验证。</p>

<h3 id="模型选择与训练">模型选择与训练</h3>

<p>该研究使用迁移学习，使用Inception-ResNet V2 , MobileNet v1 , NASNet-A Mobile , PNASNet-5 Mobile模型，每个batch为16张SV图片，训练轮数为13轮，动态调整学习率。</p>

<p>PS: 本文只用作学习笔记，我更多关注数据以及方法部分，后续作者对各个模型的结果进行了比较，如有兴趣请查看原文。</p>

<p>参考</p>

<p><a href="https://doi.org/10.1093/bib/bbaa370">A deep learning approach for filtering structural variants in short read sequencing data</a></p>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="paper" /><category term="SV" /><summary type="html"><![CDATA[最近在做基因组结构变异相关工作，阅读相关论文，这篇论文就是关于基因组结构变异的，主要用于从寻找出的结构变异中去除假阳性结果，获取真实结构变异。]]></summary></entry><entry><title type="html">IGV可视化BAM文件帮助理解结构变异</title><link href="https://kunmonster.github.io//2024/11/16/IGV%E5%8F%AF%E8%A7%86%E5%8C%96BAM%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82/" rel="alternate" type="text/html" title="IGV可视化BAM文件帮助理解结构变异" /><published>2024-11-16T17:42:00+08:00</published><updated>2024-11-16T17:42:00+08:00</updated><id>https://kunmonster.github.io//2024/11/16/IGV%E5%8F%AF%E8%A7%86%E5%8C%96BAM%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82</id><content type="html" xml:base="https://kunmonster.github.io//2024/11/16/IGV%E5%8F%AF%E8%A7%86%E5%8C%96BAM%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82/"><![CDATA[<p>使用二代测序数据可以检测结构变异，其主要利用insert size与建库时insert size的差异，以及pair-end orientation的异常来检测结构变异。</p>

<h3 id="insert-size">Insert size</h3>
<hr />

<p>二代测序，需要先将DNA打断成fragment length长的片段，然后加上测序接头，adapter等序列。insert size通常指文库长度，也就是两个reads起点和终点间的长度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5'                                                  3'
.....................................................
		--------&gt;                 &lt;--------
		  read1                     read2
		         -----------------
		          inner distance
		             gap size 
		-----------------------------------
				   insert size  
-----------------------------------------------------
				  fragment length
</code></pre></div></div>

<p>上图分别标注了</p>
<ul>
  <li>inner distance(gap size)：两个reads之间的长度</li>
  <li>insert size：read1起点到read2终点的距离</li>
  <li>fragment length：insert size + adapter+index序列的长度</li>
</ul>

<font style="color:red">**‼️思考：为什么两个reads没有重叠呢？**</font>

<p><em>两个read重叠固然会提升该区域测序的准确度，但是这样测序的范围就更小了，如果我们使得两个read隔开，因为是随机打断的，所以中间那段gap size在其他read pair中会出现，这样中间的也被覆盖了，并且测得范围也更大了。</em></p>

<h3 id="pair-orientation">Pair orientation</h3>
<hr />

<p>与上图read1, read2对应，我们在测序时进行双端测序，那么假设read1方向是从5’—&gt;3’ , 那么read2方向应为3’—&gt;5’,正常情况下都是上述情况，为LR，但是当出现Inversion等变异时候，Pair orientation可能会发生改变，出现LL,RR,RL等情况。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Read1                  Read2
-------&gt;  gap size &lt;--------

</code></pre></div></div>

<h3 id="异常检测">异常检测</h3>
<hr />
<p>通过insert-size异常可以检测</p>
<ul>
  <li>insertion (INS 插入)</li>
  <li>deletion (DEL 删除)</li>
</ul>

<p>通过pair-end orientation异常可以检测</p>
<ul>
  <li>inversion (INV 倒位)</li>
  <li>inverted duplication (倒位重复)</li>
  <li>Tandem duplication (DUP 串联重复)</li>
  <li>Translocation on the same chromosome (TRA 易位)</li>
</ul>

<h3 id="deletion对应bam文件在igv中可视化的理解">Deletion对应Bam文件在IGV中可视化的理解</h3>
<hr />

<p>首先我们考虑，如果样本基因组中某区域发生了DEL会产生什么现象</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">

</span><span class="n">参考基因组</span><span class="w">
		     </span><span class="n">A</span><span class="w">          </span><span class="n">B</span><span class="w">
</span><span class="o">---------------------------------------</span><span class="w">


</span><span class="n">在样本基因组中</span><span class="p">,</span><span class="n">假设A</span><span class="o">--</span><span class="n">B序列缺失</span><span class="p">,</span><span class="n">那么会有一对pair</span><span class="o">-</span><span class="n">end</span><span class="p">,</span><span class="n">read1在A的左边</span><span class="p">,</span><span class="n">read2在B右边</span><span class="p">,</span><span class="n">这一对reads比对到参考基因组的时候</span><span class="p">,</span><span class="n">产生的insert</span><span class="w"> </span><span class="n">size将大于对样本建库时的insert</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="n">因为在样本中他们已经是紧邻着的了</span><span class="p">,</span><span class="n">但是在参考基因组中他们中间相隔了一个AB序列.</span><span class="w">

</span><span class="n">比对到参考基因组</span><span class="w">
			 </span><span class="n">A</span><span class="w">          </span><span class="n">B</span><span class="w">
</span><span class="o">-------------|</span><span class="err">··········</span><span class="o">|--------------</span><span class="w">
</span><span class="o">-------------</span><span class="w">   </span><span class="n">直接相连</span><span class="w">  </span><span class="o">--------------</span><span class="w">
	   </span><span class="o">----&gt;</span><span class="w">              </span><span class="o">&lt;----</span><span class="w">
       </span><span class="n">read1</span><span class="w">              </span><span class="n">read2</span><span class="w">
       </span><span class="o">------------------------</span><span class="w">
        </span><span class="n">样本中的reads</span><span class="o">-</span><span class="n">pair比对到</span><span class="w">
        </span><span class="n">参考基因组的insert</span><span class="w"> </span><span class="n">size</span><span class="w">


</span><span class="n">样本基因组比该片段要比上图的参考基因组短一点</span><span class="p">,</span><span class="w">
</span><span class="o">---------------------------</span><span class="w">
	</span><span class="o">----&gt;</span><span class="w">   </span><span class="o">&lt;----</span><span class="w">
    </span><span class="n">read1</span><span class="w">   </span><span class="n">read2</span><span class="w">
    </span><span class="o">-------------</span><span class="w">
     </span><span class="n">insert</span><span class="w"> </span><span class="n">size</span><span class="w">


</span><span class="n">很明显样本中的reads</span><span class="o">-</span><span class="n">pair比对到参考基因组产生的insert</span><span class="w"> </span><span class="n">size大于该样本建库时的insert</span><span class="w"> </span><span class="n">size或者说预期的insert</span><span class="w"> </span><span class="n">size</span><span class="w">

</span></code></pre></div></div>

<p>下面是一个DEL的例子，接下来看BAM文件在IGV中的展示</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">CHROM</th>
      <th style="text-align: center">POS</th>
      <th style="text-align: center">ID</th>
      <th style="text-align: center">REF</th>
      <th style="text-align: center">ALT</th>
      <th style="text-align: center">QUAL</th>
      <th style="text-align: center">FILTER</th>
      <th style="text-align: center">INFO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">NC_037328.1</td>
      <td style="text-align: center">1895458</td>
      <td style="text-align: center">9784</td>
      <td style="text-align: center">N</td>
      <td style="text-align: center">&lt;DEL&gt;</td>
      <td style="text-align: center">14942</td>
      <td style="text-align: center">PASS</td>
      <td style="text-align: center">CIEND=0,0;CIPOS=-2,0;CHR2=NC_037328.1;END=1895994;SVLEN=-536;········</td>
    </tr>
  </tbody>
</table>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202411151719562.png" alt="image.png" /></p>

<ul>
  <li>
    <p>注意上图中蓝色箭头，在蓝色箭头处reads覆盖度发生了明显变化，再看下面红色的reads,这些就是insert size出现异常的reads</p>
  </li>
  <li>红色表示，比对到参考基因组的insert size大于建库时预期的insert size,也就是上文提到的DEL会出现的情况</li>
  <li>中间样本除了红色reads,还有正常的Reads,覆盖了该区域，说明该样本只是部分变异，可以认为其一条染色体发生了该DEL，但是另一条并没有发生</li>
</ul>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202411152233830.png" alt="{375849B0-AAA2-4C69-AF38-C3935C10C95F}.png" /></p>

<p>如上图，随即点开一个标记为红色的read-pair,可以看到其insert size为844，但是建库时为300-500bp，显然这个insert size大于建库的insert size,那么判断发生了缺失</p>

<h3 id="insertion在bam文件中体现">Insertion在bam文件中体现</h3>
<hr />

<p>同上面的DEL一样， 首先考虑，如果样本基因组中产生了INS会出现什么现象</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
                </span><span class="o">|</span><span class="w">
</span><span class="o">-------------------------------</span><span class="w">    </span><span class="n">参考基因组</span><span class="w"> 


</span><span class="o">--------------</span><span class="err">······</span><span class="o">---------------</span><span class="w">  </span><span class="n">样本基因组</span><span class="p">,</span><span class="n">中间部分发生了插入</span><span class="w">
	  </span><span class="o">------&gt;</span><span class="w">        </span><span class="o">&lt;------</span><span class="w">
	   </span><span class="n">read1</span><span class="w">          </span><span class="n">read2</span><span class="w">          </span><span class="n">样本基因组建库测序产生</span><span class="w">
	  </span><span class="o">----------------------</span><span class="w">
	       </span><span class="n">insert</span><span class="w"> </span><span class="n">size</span><span class="w">
	       
</span><span class="n">但是我们要比对到的是参考基因组</span><span class="err">，</span><span class="n">由于参考基因组中没有中间插入的一段</span><span class="err">，</span><span class="n">所以将会造成以下结果</span><span class="w">
                </span><span class="o">|</span><span class="w">
</span><span class="o">-------------------------------</span><span class="w">    </span><span class="n">参考基因组</span><span class="w"> 
	     </span><span class="o">------&gt;</span><span class="w"> </span><span class="o">&lt;------</span><span class="w">
	      </span><span class="n">read1</span><span class="w">   </span><span class="n">read2</span><span class="w">          
	     </span><span class="o">---------------</span><span class="w">
	    </span><span class="n">比对产生insert</span><span class="w"> </span><span class="n">size</span><span class="w">    
	    
</span><span class="n">很显然</span><span class="p">,</span><span class="n">来自样本中的reads比对到参考基因组时</span><span class="p">,</span><span class="n">比对产生的insert</span><span class="w"> </span><span class="n">size明显小于建库时的预期</span><span class="err">，</span><span class="n">推断此处发生了插入</span><span class="w">
</span></code></pre></div></div>

<p>下面是一个例子</p>

<p>vcf记录</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">CHROM</th>
      <th style="text-align: center">POS</th>
      <th style="text-align: center">ID</th>
      <th style="text-align: center">REF</th>
      <th style="text-align: center">ALT</th>
      <th style="text-align: center">QUAL</th>
      <th style="text-align: center">FILTER</th>
      <th style="text-align: center">INFO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">NC_037329.1</td>
      <td style="text-align: center">120047817</td>
      <td style="text-align: center">NC_037329.1:120047817:IG</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">TGAACCCACATGTGTGATAGATGGTACA</td>
      <td style="text-align: center">8962</td>
      <td style="text-align: center">PASS</td>
      <td style="text-align: center">ABHet=0.542;ABHom=0.9893;AC=46;AF=0.4259;···</td>
    </tr>
  </tbody>
</table>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202411161128117.png" alt="image.png" /></p>

<p>图中表示了一个27bp的插入，序列如图，并且能观察到该区域比对产生的insert size为212。显然，建库时我们预期为300-500bp显然更小，说明上述比对insert size &lt; 建库insert szie时可能显示有插入发生，是合理的</p>

<font style="color:red"> ** !! 注意:** *这种方式能检测插入的长度是有限的,当建库测序的inesrt size长度不足以覆盖整个插入片段以及两条reads时，那么read2将会有一部分在插入序列里面,此时比对，read2将会无法比对上,或者部分比对，此时没办法判断是因为read质量低还是插入或者其他情况造成的。*</font>

<h3 id="inversion-倒位">Inversion-倒位</h3>
<hr />

<p>倒位，指一个片段的DNA在原位置方向发生颠倒，下面看一下如果发生了倒位，比对到参考基因组将会发生什么事情</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">           </span><span class="n">A</span><span class="w">                         </span><span class="n">B</span><span class="w">  
</span><span class="o">---------------------------------------------</span><span class="w">  </span><span class="n">参考基因组</span><span class="w">


           </span><span class="n">B</span><span class="w">                         </span><span class="n">A</span><span class="w">  
</span><span class="o">---------------------------------------------</span><span class="w">  </span><span class="n">样本基因组</span><span class="w">


</span><span class="n">在样本基因组中</span><span class="p">,</span><span class="n">AB段序列与参考基因组相比发生了颠倒</span><span class="p">,</span><span class="n">但是我们不清楚</span><span class="p">,</span><span class="n">正常建库测序</span><span class="p">,</span><span class="n">假设我们在样本基因组中有以下测序片段</span><span class="w">


           </span><span class="n">B</span><span class="w">                         </span><span class="n">A</span><span class="w">  
</span><span class="o">---------------------------------------------</span><span class="w">  </span><span class="n">样本基因组</span><span class="w">
   </span><span class="o">------&gt;</span><span class="w">   </span><span class="o">&lt;------</span><span class="w">           
   </span><span class="n">readB</span><span class="m">-1</span><span class="w">   </span><span class="n">readB</span><span class="m">-2</span><span class="w">
                            </span><span class="o">------&gt;</span><span class="w">     </span><span class="o">&lt;------</span><span class="w">
                            </span><span class="n">readA</span><span class="m">-1</span><span class="w">     </span><span class="n">readA</span><span class="m">-2</span><span class="w">


</span><span class="n">现在将上述测序reads比对到参考基因组</span><span class="p">,</span><span class="n">将会发生什么呢</span><span class="o">?</span><span class="w">

           </span><span class="n">A</span><span class="w">                         </span><span class="n">B</span><span class="w">  
</span><span class="o">---------------------------------------------</span><span class="w">  </span><span class="n">参考基因组</span><span class="w">
   </span><span class="o">------&gt;</span><span class="w">   </span><span class="o">&lt;------</span><span class="w">           
   </span><span class="n">readB</span><span class="m">-1</span><span class="w">   </span><span class="n">readA</span><span class="m">-1</span><span class="w">
                            </span><span class="o">------&gt;</span><span class="w">     </span><span class="o">&lt;------</span><span class="w">
                            </span><span class="n">readB</span><span class="m">-2</span><span class="w">     </span><span class="n">readA</span><span class="m">-2</span><span class="w">

</span><span class="n">可以看到</span><span class="p">,</span><span class="n">在AB序列内部的reads</span><span class="p">,</span><span class="n">比对的方向居然和其配对的reads方向一致</span><span class="err">，</span><span class="n">也就是出现了LL</span><span class="p">,</span><span class="n">RR类型</span><span class="err">，</span><span class="n">指示可能发生了倒位</span><span class="err">。</span><span class="w">



</span></code></pre></div></div>

<font style="color:red"> ** !! 注意:** *只有当一对reads一半在倒位序列内部，一半在倒位序列外部的时候，才会出现这种异常.
*</font>

<h3 id="invert-duplication-倒位重复">Invert Duplication-倒位重复</h3>
<hr />

<p>倒位重复：指一小段序列在基因组上另一个位置发生了倒位并且插入进该位置</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">       </span><span class="n">A</span><span class="w">            </span><span class="n">B</span><span class="w">           
</span><span class="o">------------------------------------</span><span class="w"> </span><span class="n">参考基因组</span><span class="w">

       </span><span class="n">A</span><span class="w">            </span><span class="n">B</span><span class="w">               </span><span class="n">B</span><span class="w">            </span><span class="n">A</span><span class="w">
</span><span class="o">-----------------------------------------------------</span><span class="w"> </span><span class="n">样本基因组</span><span class="w">


</span><span class="n">在样本基因组中AB片段在另一个位置发生了倒位重复</span><span class="p">,</span><span class="n">我们对样本基因组进行建库测序</span><span class="w">


       </span><span class="n">A</span><span class="w">            </span><span class="n">B</span><span class="w">               </span><span class="n">B</span><span class="s1">'            A'</span><span class="w">
</span><span class="o">------------------------------------------------------</span><span class="w"> </span><span class="n">样本基因组</span><span class="w">
 </span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">
 </span><span class="n">readA1</span><span class="w">  </span><span class="n">readA2</span><span class="w">
              </span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">   </span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">
              </span><span class="n">readB1</span><span class="w">  </span><span class="n">readB2</span><span class="w"> </span><span class="n">readB</span><span class="s1">'1  readB'</span><span class="m">2</span><span class="w">

                                            </span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">
                                           </span><span class="n">readA</span><span class="s1">'1  readA'</span><span class="m">2</span><span class="w">

</span><span class="n">将上述reads比对到参考基因组</span><span class="p">,</span><span class="n">将会发生什么呢</span><span class="o">?</span><span class="w">

       </span><span class="n">A</span><span class="w">            </span><span class="n">B</span><span class="w">           
</span><span class="o">--------------------------------------------------</span><span class="w"> </span><span class="n">参考基因组</span><span class="w">
 </span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">
 </span><span class="n">readA1</span><span class="w">  </span><span class="n">readA2</span><span class="w">
              </span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">   </span><span class="o">----&gt;</span><span class="w">                 </span><span class="o">&lt;----</span><span class="w">
             </span><span class="n">readB1</span><span class="w">   </span><span class="n">readB2</span><span class="w">  </span><span class="n">readB</span><span class="s1">'1               readA'</span><span class="m">2</span><span class="w">                               </span><span class="o">----&gt;</span><span class="w">
             </span><span class="n">readB</span><span class="s1">'2
         &lt;----
         readA'</span><span class="m">1</span><span class="w">

</span><span class="n">因为在样本基因组中有两段这个区域</span><span class="err">，</span><span class="n">所以比对后AB段的coverage</span><span class="p">(</span><span class="n">覆盖度</span><span class="p">)</span><span class="n">应该会有明显上升</span><span class="err">，</span><span class="n">IGV官方文档说会有大量的左右read重叠</span><span class="err">？</span><span class="n">有待考证</span><span class="err">···</span><span class="w">
</span></code></pre></div></div>

<h3 id="tandem-duplication-串联重复">Tandem duplication-串联重复</h3>
<hr />

<p>串联重复: 在一段序列后面紧跟着重复该片段</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">       </span><span class="n">A</span><span class="w">              </span><span class="n">B</span><span class="w">
</span><span class="o">-----------------------------------</span><span class="w">   </span><span class="n">参考基因组</span><span class="w">

       </span><span class="n">A</span><span class="w">              </span><span class="n">B</span><span class="w">
</span><span class="o">------------------------------------------------------------</span><span class="w"> </span><span class="n">样本基因组</span><span class="w">
                      </span><span class="n">A</span><span class="w">              </span><span class="n">B</span><span class="w">
		         </span><span class="o">---&gt;</span><span class="err">···</span><span class="o">&lt;---</span><span class="w">
				</span><span class="n">read1</span><span class="w">   </span><span class="n">read2</span><span class="w">

</span><span class="n">上述样本基因组发生了AB序列串联重复</span><span class="p">,</span><span class="n">对其进行建库测序</span><span class="p">,</span><span class="n">再比对到参考基因组</span><span class="w">

       </span><span class="n">A</span><span class="w">              </span><span class="n">B</span><span class="w">
</span><span class="o">-----------------------------------</span><span class="w">   </span><span class="n">参考基因组</span><span class="w">
		</span><span class="o">&lt;---</span><span class="w">       </span><span class="o">---&gt;</span><span class="w">
		</span><span class="n">read2</span><span class="w">	   </span><span class="n">read1</span><span class="w">

</span><span class="n">很显然read2本来应该再read1下游位置</span><span class="err">，</span><span class="n">但是跑到了上游</span><span class="p">,</span><span class="n">但是方向未变</span><span class="w">
</span><span class="n">IGV文档中没提到</span><span class="p">,</span><span class="n">这个位置的coverage应该也会上升</span><span class="w">

</span></code></pre></div></div>

<h3 id="translocation-on-the-same-chromosome-易位">Translocation on the same chromosome-易位</h3>
<hr />

<p>同染色体易位: 染色体上的某一段序列，从原位置移动到该染色体的另一位置</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">      </span><span class="n">A</span><span class="w">                </span><span class="n">B</span><span class="w">    
</span><span class="o">-------------------------------------------------------------</span><span class="w"> </span><span class="n">参考基因组</span><span class="w">


                                      </span><span class="n">A</span><span class="w">                </span><span class="n">B</span><span class="w">    
</span><span class="o">-------------------------------------------------------------</span><span class="w"> </span><span class="n">样本基因组</span><span class="w">
								</span><span class="o">----&gt;</span><span class="err">···</span><span class="o">&lt;----</span><span class="w">
								</span><span class="n">read1</span><span class="w">   </span><span class="n">read2</span><span class="w">

</span><span class="n">上述样本基因组出现了同染色体易位变异</span><span class="p">,</span><span class="n">对其进行建库测序</span><span class="p">,</span><span class="n">再比对到参考基因组</span><span class="w">


      </span><span class="n">A</span><span class="w">                </span><span class="n">B</span><span class="w">    
</span><span class="o">-------------------------------------------------------------</span><span class="w"> </span><span class="n">参考基因组</span><span class="w">
		</span><span class="o">&lt;----</span><span class="w">				    </span><span class="o">----&gt;</span><span class="w">
		</span><span class="n">read2</span><span class="w">					</span><span class="n">read1</span><span class="w">

</span><span class="n">可以观察到</span><span class="p">,</span><span class="n">测序产生reads比对到参考基因组后read1正常比对到原来的位置</span><span class="p">,</span><span class="n">但是配对的read2比对到了AB区间内</span><span class="p">,</span><span class="n">但是检测易位真是通过这个吗</span><span class="o">?</span><span class="w"> 

</span><span class="o">@</span><span class="n">TODO</span><span class="o">:</span><span class="n">研究一下calling</span><span class="w"> </span><span class="n">sv的原理</span><span class="w">
</span></code></pre></div></div>

<h3 id="end">End</h3>
<hr />

<p>以上内容来自本人对IGV中可视化bam文件部分的理解,因为似乎没有在互联网上找到相关的信息，直接从reads角度来看SV有助于更好理解结构变异的calling过程!</p>

<h3 id="reference">Reference</h3>

<p><a href="https://igv.org/doc/desktop/#UserGuide/tracks/alignments/paired_end_alignments/#inverted-duplication">IGV paired-end alignments</a></p>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="SV" /><category term="IGV" /><category term="BAM" /><summary type="html"><![CDATA[使用二代测序数据可以检测结构变异，其主要利用insert size与建库时insert size的差异，以及pair-end orientation的异常来检测结构变异。]]></summary></entry><entry><title type="html">使用Matrix-eQTL完成cis-eQTL定位</title><link href="https://kunmonster.github.io//2024/10/25/%E4%BD%BF%E7%94%A8Matrix-eQTL%E5%AE%8C%E6%88%90cis-eQTL%E5%AE%9A%E4%BD%8D/" rel="alternate" type="text/html" title="使用Matrix-eQTL完成cis-eQTL定位" /><published>2024-10-25T21:05:00+08:00</published><updated>2024-10-25T21:05:00+08:00</updated><id>https://kunmonster.github.io//2024/10/25/%E4%BD%BF%E7%94%A8Matrix-eQTL%E5%AE%8C%E6%88%90cis-eQTL%E5%AE%9A%E4%BD%8D</id><content type="html" xml:base="https://kunmonster.github.io//2024/10/25/%E4%BD%BF%E7%94%A8Matrix-eQTL%E5%AE%8C%E6%88%90cis-eQTL%E5%AE%9A%E4%BD%8D/"><![CDATA[<h2 id="表达数量性状位点eqtl">表达数量性状位点（eQTL）</h2>
<hr />

<p>基因组上有些区域能导致某些基因的表达(mRNA)产生明显的变化，这些位置或者区域被称为表达数量性状位点(eQTL)，一般认为离目标基因1Mb位置以内的为顺式位点（local-eQTLs ， cis-eQTLs），与目标基因位置超过1Mb的成为反式位点（distant-eQTLs ， trans-eQTLs），主要通过线性回归对兴趣位点与目标基因表达量进行回归，并检验关系是否显著。</p>

<h2 id="使用matrix-eqtl进行大规模eqtl定位">使用Matrix eQTL进行大规模eQTL定位</h2>
<hr />

<p>本文只进行cis-eQTL和trans-eQTL定位，以下是本人真实研究数据在此进行举例并为自己提供笔记</p>

<h3 id="数据准备">数据准备</h3>
<hr />

<p>进行cis-eQTL和trans-eQTL定位需要准备以下数据</p>

<ul>
  <li>snp_genotype_matrix（基因分型矩阵，行为snp id，列为每个样本）(本例子中使用sv)</li>
</ul>

<blockquote>
  <ol>
    <li>snpid必须与下面的snp_loc中的id一样，并且sample_name的顺序必须和下面的expression_matrix中的sample_name顺序一致。</li>
    <li>并且matrix指的是R语言中的matrix，所以第一列就直接是值了，snpid应该设置为rowname。</li>
  </ol>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">snpid</th>
      <th>sample_name-1</th>
      <th>sample_name-2</th>
      <th>sample_name-3</th>
      <th>……</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td>0（基因型）</td>
      <td>1（基因型）</td>
      <td>2（基因型）</td>
      <td>……</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>expression_matrix（表达量矩阵，行为基因名或者基因ID,只要与下面的gene_pos中的一致即可，列为每个样本）</li>
</ul>

<blockquote>
  <ol>
    <li>注意表达量必须为数值类型的</li>
    <li>基因名字必须与下面的gene_pos中的基因名一致</li>
    <li>基因名字作为matrix的rowname</li>
  </ol>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">gene_id</th>
      <th>sample_name-1</th>
      <th>sample_name-2</th>
      <th>sample_name-3</th>
      <th>……</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">gene_id</td>
      <td>该基因在该样本的表达量</td>
      <td>同左</td>
      <td>同左</td>
      <td>……</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>gene_pos（基因相关信息）</li>
</ul>

<blockquote>
  <p>该文件应该以data.frame形式存入R对象中，并且列名应该严格按照下面的示例</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">geneid</th>
      <th>chr</th>
      <th>left</th>
      <th>right</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">基因ID</td>
      <td>染色体号</td>
      <td>基因起点</td>
      <td>基因终点</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>snp_loc （变异位点信息）</li>
</ul>

<blockquote>
  <p>同上，本内容也应在R中使用data.frame对象存放，列名如下</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">snpid</th>
      <th>chr</th>
      <th>pos</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">变异ID</td>
      <td>染色体号</td>
      <td>变异位置</td>
    </tr>
  </tbody>
</table>

<h3 id="matrix-eqtl-api简介">Matrix eQTL api简介</h3>
<hr />
<p>matrix eQTL使用R编写，以快速进行大规模eQTL定位为人熟知，下面是本例要用的api以及主要参数解释</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="c1"># 本例子中主要使用Matrix_eQTL_main function</span><span class="w">
</span><span class="c1"># 其主要参数及解释如下</span><span class="w">

</span><span class="n">Matrix_eQTL_main</span><span class="p">(</span><span class="w">
        </span><span class="n">snps</span><span class="p">,</span><span class="w"> </span><span class="c1"># 基因型矩阵，需要SliceData对象,要求见数据准备部分,SliceData稍后介绍 </span><span class="w">
        </span><span class="n">gene</span><span class="p">,</span><span class="w"> </span><span class="c1"># 表达量矩阵，需要SliceData对象</span><span class="w">
        </span><span class="n">cvrt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SlicedData</span><span class="o">$</span><span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="c1"># 协变量，默认为空</span><span class="w">
        </span><span class="n">output_file_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w"> </span><span class="c1"># 默认输出文件</span><span class="w">
        </span><span class="n">pvOutputThreshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1e-5</span><span class="p">,</span><span class="w"> </span><span class="c1"># 显著阈值,默认值10^(-5)</span><span class="w">
        </span><span class="n">useModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modelLINEAR</span><span class="p">,</span><span class="w"> </span><span class="c1"># 模型选择,默认线性模型,还有两种其他模型,见Matrix eQTL文档</span><span class="w">
        </span><span class="n">errorCovariance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numeric</span><span class="p">(),</span><span class="w">  
        </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="c1"># 过程日志输出</span><span class="w">
        </span><span class="n">output_file_name.cis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w"> </span><span class="c1"># cis-eQTL显著关联结果的输出文件 </span><span class="w">
        </span><span class="n">pvOutputThreshold.cis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="c1"># cis-eQTL的显著值阈值</span><span class="w">
        </span><span class="n">snpspos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="c1"># data.frame,cis-eQTL和trans-eQTL需要,因为需要提供snp的位置</span><span class="w">
        </span><span class="n">genepos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="c1"># data.frame,同理在进行cis-eQTl和trans-eQTL时需要</span><span class="w">
        </span><span class="n">cisDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1e6</span><span class="p">,</span><span class="w"> </span><span class="c1"># cis-eQTL的距离，默认为1Mb范围内</span><span class="w">
        </span><span class="n">pvalue.hist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w">
        </span><span class="n">min.pv.by.genesnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w">
        </span><span class="n">noFDRsaveMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">

</span><span class="c1"># 注意如果不指定pvOutputThreshold.cis,snpspos,genepos将不会进行cis-eQTL和trans-eQTL分析,将会对所有候选位点和候选基因进行关联分析</span><span class="w">

</span><span class="c1"># 当 pvOutputThreshold=0, pvOutputThreshold.cis&gt;0时将只进行cis-eQTL分析</span><span class="w">
</span><span class="c1"># 当 pvOutputThreshold&gt;0,pvOutputThreshold.cis&gt;0时将进行cis-eQTL和trans-eQTl,其中trans-eQTL显著值使用pvOutputThreshold</span><span class="w">


</span><span class="c1"># 注意，前面在数据准备过程中,snp_genotype_matrix,expression_matrix被存成R矩阵,但是上面api要求输入SliceData对象</span><span class="w">
</span><span class="c1"># 所以需要转换成SliceData对象,SliceData类是Matrix eQTL中的一个用于矩阵的类,具体可以其帮助中查看</span><span class="w">

</span></code></pre></div></div>

<h3 id="具体实施过程">具体实施过程</h3>

<p>数据示例</p>

<p>gene_expression:读取进来的时候使用data.frame存储，后面要进行处理</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202410240942849.png" alt="image.png" /></p>

<p>genotype:同上，以data.frame存储，后续要进行处理</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202410240943149.png" alt="image.png" /></p>

<p>snp_pos:这个读取进来用data.frame存储即可，但是列名需要更换，第一列的ID应该与genotype中的ID一致
<img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202410240944479.png" alt="image.png" /></p>

<p>gene_pos:读取进来直接使用data.frame存储，gene_id列应与gene_exp中行名保持一致</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202410240953497.png" alt="image.png" /></p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 读取需要的文件</span><span class="w">
</span><span class="c1"># 基因位置</span><span class="w">
</span><span class="n">gene_pos</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s1">'path_to/gene_pos.csv'</span><span class="p">,</span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="c1"># 候选变异的位置信息</span><span class="w">
</span><span class="n">sv_loc</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s1">'path_to/sv_loc.csv'</span><span class="p">,</span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">genotype</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s1">'path_to/genotype.csv'</span><span class="p">,</span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">gene_expression</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s1">'path_to/expression_tpm.csv'</span><span class="p">,</span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">


</span><span class="c1"># 过滤基因表达量低的基因,每个基因在所有的样本中有sample_percentage百分比的样本的表达量高于threshold才保留,并进行log转换</span><span class="w">
</span><span class="n">filter_low_expression_genes</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">expr_matrix</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">sample_percentage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">gene_names</span><span class="o">&lt;-</span><span class="n">expr_matrix</span><span class="p">[,</span><span class="m">1</span><span class="p">]</span><span class="w">
  </span><span class="n">expr_values</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.data.frame</span><span class="p">(</span><span class="n">lapply</span><span class="p">(</span><span class="n">expr_matrix</span><span class="p">[,</span><span class="w"> </span><span class="m">-1</span><span class="p">],</span><span class="w"> </span><span class="n">as.numeric</span><span class="p">))</span><span class="w">
  </span><span class="c1"># 计算超过阈值的样本数量阈值</span><span class="w">
  </span><span class="n">sample_threshold</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">ceiling</span><span class="p">(</span><span class="n">ncol</span><span class="p">(</span><span class="n">expr_values</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sample_percentage</span><span class="p">)</span><span class="w">
  </span><span class="c1"># 对每个基因，计算在样本中TPM&gt;=1的样本数</span><span class="w">
  </span><span class="n">filtered_matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">expr_matrix</span><span class="p">[</span><span class="n">rowSums</span><span class="p">(</span><span class="n">expr_values</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">threshold</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">sample_threshold</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w">
  </span><span class="c1"># 对过滤后的表达矩阵进行 log2 转换 (log2(TPM + 1))  </span><span class="w">
  </span><span class="n">log_transformed_matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">log2</span><span class="p">(</span><span class="n">filtered_matrix</span><span class="p">[,</span><span class="m">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="n">log_transformed_matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">Gene</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gene_names</span><span class="p">[</span><span class="n">rowSums</span><span class="p">(</span><span class="n">expr_values</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">threshold</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">sample_threshold</span><span class="p">],</span><span class="w"> </span><span class="n">log_transformed_matrix</span><span class="p">)</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="n">log_transformed_matrix</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">


</span><span class="c1"># 检查基因位置和表达矩阵中基因的交集并返回</span><span class="w">
</span><span class="c1"># param: 表达矩阵,基因信息</span><span class="w">
</span><span class="n">check_the_cross</span><span class="o">&lt;-</span><span class="k">function</span><span class="p">(</span><span class="n">gene_exp</span><span class="p">,</span><span class="n">gene_pos</span><span class="p">){</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">gene_exp</span><span class="p">)){</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"表达矩阵不存在"</span><span class="p">)</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="m">-1</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">gene_pos</span><span class="p">)){</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"基因信息不存在"</span><span class="p">)</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="m">-1</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="k">else</span><span class="p">{</span><span class="w">
    </span><span class="n">library</span><span class="p">(</span><span class="n">dplyr</span><span class="p">)</span><span class="w">
    </span><span class="n">result</span><span class="o">&lt;-</span><span class="n">filter_low_expression_genes</span><span class="p">(</span><span class="n">gene_exp</span><span class="p">)</span><span class="w">
    </span><span class="n">result</span><span class="o">&lt;-</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
      </span><span class="n">filter</span><span class="p">(</span><span class="n">result</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">gene_pos</span><span class="p">[[</span><span class="m">1</span><span class="p">]])</span><span class="w">
    </span><span class="c1"># 处理表达量数据，去除表达量小的基因</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># 只保留兴趣基因的的表达量</span><span class="w">
</span><span class="n">gene_expression_cross</span><span class="o">&lt;-</span><span class="n">check_the_cross</span><span class="p">(</span><span class="n">gene_expression</span><span class="p">,</span><span class="n">gene_pos</span><span class="p">)</span><span class="w">
</span><span class="n">new_genotype</span><span class="o">&lt;-</span><span class="n">genotype</span><span class="w">
</span><span class="c1"># 将genotype中的缺失值替换成NA</span><span class="w">
</span><span class="n">new_genotype</span><span class="p">[</span><span class="n">new_genotype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"."</span><span class="p">]</span><span class="o">&lt;-</span><span class="kc">NA</span><span class="w">

</span><span class="c1"># 获取表达矩阵和基因型矩阵中样本的交集(有些样本没有表达数据，有些样本没有基因型数据)</span><span class="w">
</span><span class="n">common_names</span><span class="o">&lt;-</span><span class="n">intersect</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">gene_expression_cross</span><span class="p">),</span><span class="nf">names</span><span class="p">(</span><span class="n">new_genotype</span><span class="p">))</span><span class="w">
</span><span class="n">gene_expression_cross</span><span class="o">&lt;-</span><span class="n">gene_expression_cross</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s1">'Gene'</span><span class="p">,</span><span class="n">common_names</span><span class="p">)]</span><span class="w">
</span><span class="n">new_genotype</span><span class="o">&lt;-</span><span class="n">new_genotype</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s1">'ID'</span><span class="p">,</span><span class="n">common_names</span><span class="p">)]</span><span class="w">

</span><span class="c1"># 按列名排序，确保两个data.frame列名序一样，这很重要</span><span class="w">
</span><span class="n">gene_expression_cross</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">gene_expression_cross</span><span class="p">[,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s1">'Gene'</span><span class="p">,</span><span class="nf">names</span><span class="p">(</span><span class="n">gene_expression_cross</span><span class="p">)[</span><span class="m">-1</span><span class="p">][</span><span class="n">order</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">gene_expression_cross</span><span class="p">)[</span><span class="m">-1</span><span class="p">])])]</span><span class="w">
</span><span class="n">new_genotype</span><span class="o">&lt;-</span><span class="n">new_genotype</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s1">'ID'</span><span class="p">,</span><span class="nf">names</span><span class="p">(</span><span class="n">new_genotype</span><span class="p">)[</span><span class="m">-1</span><span class="p">][</span><span class="n">order</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">new_genotype</span><span class="p">)[</span><span class="m">-1</span><span class="p">])])]</span><span class="w">


</span><span class="c1"># 由于matrix_eqtl需要特定类型的数据，所以将data.frame去掉列名，首列后，转换成matrix</span><span class="w">
</span><span class="c1"># 取出第一列作为后续矩阵的行名</span><span class="w">
</span><span class="n">row_name</span><span class="o">&lt;-</span><span class="n">gene_expression_cross</span><span class="o">$</span><span class="n">Gene</span><span class="w">
</span><span class="c1"># 去除第一列</span><span class="w">
</span><span class="n">gene_exp_matrix</span><span class="o">&lt;-</span><span class="n">gene_expression_cross</span><span class="p">[,</span><span class="m">-1</span><span class="p">]</span><span class="w">
</span><span class="c1"># 列名置空</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">gene_exp_matrix</span><span class="p">)</span><span class="o">&lt;-</span><span class="kc">NULL</span><span class="w">
</span><span class="c1"># 转换为矩阵</span><span class="w">
</span><span class="n">gene_exp_matrix</span><span class="o">&lt;-</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">gene_exp_matrix</span><span class="p">)</span><span class="w">
</span><span class="c1"># 再给矩阵指定rowname</span><span class="w">
</span><span class="n">row.names</span><span class="p">(</span><span class="n">gene_exp_matrix</span><span class="p">)</span><span class="o">&lt;-</span><span class="n">row_name</span><span class="w">

</span><span class="c1"># 同样操作</span><span class="w">
</span><span class="n">row_name_genotype</span><span class="o">&lt;-</span><span class="n">new_genotype</span><span class="o">$</span><span class="n">ID</span><span class="w">
</span><span class="n">genotype_matrix</span><span class="o">&lt;-</span><span class="n">new_genotype</span><span class="p">[,</span><span class="m">-1</span><span class="p">]</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">)</span><span class="o">&lt;-</span><span class="kc">NULL</span><span class="w">
</span><span class="n">genotype_matrix</span><span class="o">&lt;-</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">)</span><span class="w">

</span><span class="c1"># 将矩阵的值转换为数值</span><span class="w">
</span><span class="n">genotype_matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">),</span><span class="w"> </span><span class="n">nrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">))</span><span class="w">
</span><span class="n">rownames</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">)</span><span class="o">&lt;-</span><span class="n">row_name_genotype</span><span class="w">

</span><span class="c1"># 使得两data.frame列名满足输入要求</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">sv_loc</span><span class="p">)</span><span class="o">&lt;-</span><span class="nf">c</span><span class="p">(</span><span class="s1">'snpid'</span><span class="p">,</span><span class="s1">'chr'</span><span class="p">,</span><span class="s1">'pos'</span><span class="p">)</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">gene_pos</span><span class="p">)</span><span class="o">&lt;-</span><span class="nf">c</span><span class="p">(</span><span class="s1">'geneid'</span><span class="p">,</span><span class="s1">'chr'</span><span class="p">,</span><span class="s1">'left'</span><span class="p">,</span><span class="s1">'right'</span><span class="p">)</span><span class="w">

</span><span class="c1"># 确保gene_pos中的基因和表达矩阵中的基因一致（因为前面对表达矩阵进行了过滤，有些基因被滤除）</span><span class="w">
</span><span class="n">gene_pos</span><span class="o">&lt;-</span><span class="n">gene_pos</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">filter</span><span class="p">(</span><span class="n">gene_pos</span><span class="o">$</span><span class="n">geneid</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">gene_expression_cross</span><span class="o">$</span><span class="n">Gene</span><span class="p">)</span><span class="w">
  
</span><span class="c1"># eqtl相关参数</span><span class="w">
</span><span class="n">cis_threshold</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1e-5</span><span class="w">
</span><span class="n">trans_threshold</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1e-5</span><span class="w">
</span><span class="n">cis_dist</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1e6</span><span class="w">

</span><span class="n">pvOutputThreshold_cis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cis_threshold</span><span class="p">;</span><span class="w">
</span><span class="n">pvOutputThreshold_tra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trans_threshold</span><span class="p">;</span><span class="w">

</span><span class="n">cisDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cis_dist</span><span class="w">

</span><span class="n">library</span><span class="p">(</span><span class="n">MatrixEQTL</span><span class="p">)</span><span class="w">

</span><span class="n">me</span><span class="o">&lt;-</span><span class="n">Matrix_eQTL_main</span><span class="p">(</span><span class="w">
  </span><span class="n">snps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SlicedData</span><span class="p">(</span><span class="n">genotype_matrix</span><span class="p">),</span><span class="w"> </span><span class="c1"># 因为SliceData可以使用矩阵直接构造对象，所以前面转换成矩阵后直接构造SliceData对象</span><span class="w">
  </span><span class="n">gene</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SlicedData</span><span class="p">(</span><span class="n">gene_exp_matrix</span><span class="p">),</span><span class="w"> </span><span class="c1"># 同上</span><span class="w">
  </span><span class="n">pvOutputThreshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvOutputThreshold_tra</span><span class="p">,</span><span class="w">
  </span><span class="n">pvOutputThreshold.cis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pvOutputThreshold_cis</span><span class="p">,</span><span class="w">
  </span><span class="n">useModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modelLINEAR</span><span class="p">,</span><span class="w">
  </span><span class="n">errorCovariance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numeric</span><span class="p">(),</span><span class="w">
  </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w">
  </span><span class="n">snpspos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sv_loc</span><span class="p">,</span><span class="w">
  </span><span class="n">genepos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gene_pos</span><span class="p">,</span><span class="w">
  </span><span class="n">cisDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cisDist</span><span class="p">,</span><span class="w">
  </span><span class="n">output_file_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"trans_eqtls.txt"</span><span class="w">
  </span><span class="n">output_file_name.cis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"cis_eqtls.txt"</span><span class="p">,</span><span class="w">
  </span><span class="n">pvalue.hist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"qqplot"</span><span class="p">,</span><span class="w">
  </span><span class="n">min.pv.by.genesnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w">
  </span><span class="n">noFDRsaveMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w">
</span><span class="p">)</span><span class="w">

</span></code></pre></div></div>

<h3 id="结果解读">结果解读</h3>
<hr />
<p>上述定位完成后结果将存放在me对象中，该对象结构如下</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202410251307586.png" alt="image.png" /></p>

<p>其中trans与cis分别存放两种类型的eQTL位点,接下来我们挑选出FDR&lt;=0.05并且最显著的一个cis-eQTL
这里挑选出来，snp_id=68,gene_id=”LONRF3”的一组关联，我们将LONRF3的表达量列出，并且将其对应的snp genotype列出，对其做线性拟合，然后绘制箱线图展示关系</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/202410252058554.png" alt="image.png" /></p>

<p>从图中可以看出基因型的不同确实导致了表达量的变化，可能这个变异以某种机制作用于该基因的表达，具体还得后续分析。</p>

<h2 id="end">End</h2>
<hr />
<p>本文章仅记录自己使用Matrix-eQTL进行eQTL定位的过程，如有问题或者误导可联系我交流。</p>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="eqtl" /><summary type="html"><![CDATA[表达数量性状位点（eQTL）]]></summary></entry><entry><title type="html">记录windows版本IGV的一个bug的修复过程</title><link href="https://kunmonster.github.io//2024/10/09/%E8%AE%B0%E5%BD%95windows%E7%89%88%E6%9C%ACIGV%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E4%BF%AE%E5%A4%8D%E8%BF%87%E7%A8%8B/" rel="alternate" type="text/html" title="记录windows版本IGV的一个bug的修复过程" /><published>2024-10-09T15:11:00+08:00</published><updated>2024-10-09T15:11:00+08:00</updated><id>https://kunmonster.github.io//2024/10/09/%E8%AE%B0%E5%BD%95windows%E7%89%88%E6%9C%ACIGV%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E4%BF%AE%E5%A4%8D%E8%BF%87%E7%A8%8B</id><content type="html" xml:base="https://kunmonster.github.io//2024/10/09/%E8%AE%B0%E5%BD%95windows%E7%89%88%E6%9C%ACIGV%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E4%BF%AE%E5%A4%8D%E8%BF%87%E7%A8%8B/"><![CDATA[<h2 id="问题">问题</h2>
<hr />

<p>该bug在<a href="https://github.com/igvteam/igv/issues/1512">issue #1512</a>中第一次被提及，具体体现为在windows平台下打开IGV，显示IGV的命令行窗口但是不显示IGV主窗口，并且在状态栏有IGV的图标显示。</p>

<p>本人在使用时遇到上述同样的情况，并且经过一段时间定位，发现问题出现在窗口坐标上。问题具体成因如下：</p>

<ul>
  <li>IGV通过保存一个偏好文件以达到窗口在下次打开的时候重新显示在上次关闭的同一位置</li>
  <li>当有多块屏幕时，如果上次关闭时IGV所在位置的屏幕没有被连接（特别是作为主屏幕左边的副屏时）那么此时将会出现上述情况</li>
  <li>根本原因就是指定窗口大小和位置的(x,y,width,height)在上次退出时保存为
\(x+width &lt;0\)
或者
\(y+height &lt; 0\)
导致在当前屏幕上不能显示出该窗口。</li>
</ul>

<h2 id="解决">解决</h2>
<hr />

<p>由于作者使用Mac OS，无法复现该问题，所以我计划修复此bug。</p>

<p>最初我计划给 \(x+width\) 和 \(y+height\)设定一个最小值，如果小于该最小值那么直接将坐标强行拉回(0,0,1150,800)，但是此种做法将会改变原本的保留用户位置偏好的功能。在与作者讨论并且其建议采用以下修复方法</p>

<ul>
  <li>获取所有显示设备窗口坐标并存于数组中</li>
  <li>读取用户偏好坐标，并且判断左上角(x,y)是否在某一个显示设备内，如果不在，那么在主屏幕显示，并且使用默认窗口大小，如果在，那么判断用户偏好中整个窗口是否在该屏幕内，如果不在那么调整窗口大小，显示在该屏幕中</li>
</ul>

<p>具体实现见 commit 1d92ce47fc6e319222ae942f651fa14a15833e35 in <a href="https://github.com/igvteam/igv/pull/1590">issue #1590</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GraphicsEnvironment</span> <span class="n">graphEnv</span> <span class="o">=</span> <span class="nc">GraphicsEnvironment</span><span class="o">.</span><span class="na">getLocalGraphicsEnvironment</span><span class="o">();</span>  
<span class="nc">GraphicsDevice</span><span class="o">[]</span> <span class="n">graphDev</span> <span class="o">=</span> <span class="n">graphEnv</span><span class="o">.</span><span class="na">getScreenDevices</span><span class="o">();</span>  
<span class="nc">Rectangle</span><span class="o">[]</span> <span class="n">boundsArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">[</span><span class="n">graphDev</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>  
  
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">graphDev</span><span class="o">.</span><span class="na">length</span><span class="o">;++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>  
    <span class="nc">GraphicsConfiguration</span> <span class="n">curCon</span> <span class="o">=</span> <span class="n">graphDev</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getDefaultConfiguration</span><span class="o">();</span>  
    <span class="n">boundsArr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curCon</span><span class="o">.</span><span class="na">getBounds</span><span class="o">();</span>  
<span class="o">}</span>  
  
<span class="c1">//set a flag which indicates if the user preference is empty, or if the (x,y) in the user preference is not contained in any screen  </span>
<span class="c1">//default is empty or not contained  </span>
<span class="kt">boolean</span> <span class="n">isNullOrNotContained</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>  
  
<span class="k">if</span><span class="o">(</span><span class="n">applicationBounds</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>  
    <span class="c1">//Iterate over each screen value to find if there is currently a screen that can contain these values.  </span>
    <span class="kt">int</span> <span class="n">userX</span> <span class="o">=</span> <span class="n">applicationBounds</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>  
    <span class="kt">int</span> <span class="n">userY</span> <span class="o">=</span> <span class="n">applicationBounds</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>  
    <span class="kt">double</span> <span class="n">userMaxX</span> <span class="o">=</span> <span class="n">applicationBounds</span><span class="o">.</span><span class="na">getMaxX</span><span class="o">();</span>  
    <span class="kt">double</span> <span class="n">userMaxY</span> <span class="o">=</span> <span class="n">applicationBounds</span><span class="o">.</span><span class="na">getMaxY</span><span class="o">();</span>  
    <span class="k">for</span><span class="o">(</span><span class="nc">Rectangle</span> <span class="n">curScreen</span> <span class="o">:</span> <span class="n">boundsArr</span><span class="o">){</span>  
        <span class="k">if</span><span class="o">(</span><span class="n">curScreen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">userX</span><span class="o">,</span><span class="n">userY</span><span class="o">)){</span>  
            <span class="n">isNullOrNotContained</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>  
            <span class="k">if</span><span class="o">(</span> <span class="n">userMaxX</span> <span class="o">&gt;=</span> <span class="n">curScreen</span><span class="o">.</span><span class="na">getMaxX</span><span class="o">()</span> <span class="o">||</span> <span class="n">userMaxY</span> <span class="o">&gt;=</span> <span class="n">curScreen</span><span class="o">.</span><span class="na">getMaxY</span><span class="o">()){</span>  
                <span class="n">applicationBounds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">curScreen</span><span class="o">.</span><span class="na">x</span><span class="o">,</span><span class="n">curScreen</span><span class="o">.</span><span class="na">y</span><span class="o">,</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">1150</span><span class="o">,</span><span class="n">curScreen</span><span class="o">.</span><span class="na">width</span><span class="o">),</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">800</span><span class="o">,</span><span class="n">curScreen</span><span class="o">.</span><span class="na">height</span><span class="o">));</span>  
            <span class="o">}</span>  
            <span class="k">break</span><span class="o">;</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="k">if</span><span class="o">(</span><span class="n">isNullOrNotContained</span><span class="o">){</span>  
    <span class="c1">// user's preference is null or the (x,y) in user's preference is not contained in any screen  </span>
    <span class="c1">// set the application to the main screen    </span>
    <span class="n">applicationBounds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">1150</span><span class="o">,</span><span class="n">screenBounds</span><span class="o">.</span><span class="na">width</span><span class="o">),</span>
    <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">800</span><span class="o">,</span><span class="n">screenBounds</span><span class="o">.</span><span class="na">height</span><span class="o">));</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>该PR已经被作者从fix_issue1512分支合并至main分支</p>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="bioinformatics" /><category term="igv" /><summary type="html"><![CDATA[问题]]></summary></entry><entry><title type="html">理解结构变异BED在VCF中的描述</title><link href="https://kunmonster.github.io//2024/09/02/%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82BND%E5%9C%A8VCF%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/" rel="alternate" type="text/html" title="理解结构变异BED在VCF中的描述" /><published>2024-09-02T16:28:00+08:00</published><updated>2024-09-02T16:28:00+08:00</updated><id>https://kunmonster.github.io//2024/09/02/%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82BND%E5%9C%A8VCF%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA</id><content type="html" xml:base="https://kunmonster.github.io//2024/09/02/%E7%90%86%E8%A7%A3%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82BND%E5%9C%A8VCF%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/"><![CDATA[<h3 id="结构变异种类">结构变异种类</h3>
<hr />
<ul>
  <li>INFO字段: SVTYPE</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">value</th>
      <th style="text-align: center">meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">DEL</td>
      <td style="text-align: center">deletion</td>
    </tr>
    <tr>
      <td style="text-align: center">DUP</td>
      <td style="text-align: center">duplication</td>
    </tr>
    <tr>
      <td style="text-align: center"> INS</td>
      <td style="text-align: center">insertion</td>
    </tr>
    <tr>
      <td style="text-align: center">INV</td>
      <td style="text-align: center">inversion</td>
    </tr>
    <tr>
      <td style="text-align: center">CNV</td>
      <td style="text-align: center">copy number variation</td>
    </tr>
    <tr>
      <td style="text-align: center">BND</td>
      <td style="text-align: center">breakend</td>
    </tr>
  </tbody>
</table>

<h3 id="结构变异在vcf文件中具体描述">结构变异在VCF文件中具体描述</h3>
<hr />

<p>普通的变异都好理解，只是BND有点麻烦</p>

<blockquote>
  <p>ALT中会出现的四种情况</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">ALT</th>
      <th style="text-align: center">meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">N]chr:pos]</td>
      <td style="text-align: center">当前染色体是断裂染色体的左边部分、N是断裂点、从N开始向右延伸至与染色体chr的pos位置断点连接</td>
    </tr>
    <tr>
      <td style="text-align: center">]chr:pos]N</td>
      <td style="text-align: center">当前片段是断裂染色体的右边一半、N是断裂点，从N开始左边与染色体chr的pos位置断裂的片段接上，N所在的片段还是充当右边片段，接上的另一片段充当左边部分</td>
    </tr>
    <tr>
      <td style="text-align: center">N[chr:pos[</td>
      <td style="text-align: center">当前片段是断裂染色体的左边的一半，所以N就是断裂点，从该位置向右与染色体chr的pos位置接上，即接上后该片段仍充当左边，接上的另一片段就充当右边部分</td>
    </tr>
    <tr>
      <td style="text-align: center">[chr:pos[N</td>
      <td style="text-align: center">当前染色体的N，染色体断裂后右边那条的断裂点，所以从N开始，将另一条的chr断裂的pos处接到N的左边，替换掉左边断掉的</td>
    </tr>
  </tbody>
</table>

<p>总结上述四种变异的组织方式有以下规律</p>
<ul>
  <li>只要是断裂后的左边片段，那么断裂点总是出现在标识另一片段的左边，断裂的右片段同理</li>
  <li>如果两个相接的片段在断裂前分别是一左一右，那么必然是\(N[CHR:POS[\) 和 \(]CHR:POS]N\) 相连</li>
  <li>但是如果两个相接的片段在断裂前都是左边的话，那么必然是\(N]CHR:POS]\) 和 \(N]CHR:POS]\) 相连</li>
  <li>如果两个相接的片段在断裂前都是右边的话，那么必然是\([CHR:POS[N\) 和 \([CHR:POS[N\) 相连</li>
</ul>

<blockquote>
  <p>下面是官方文档给的例子</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">#CHROM</th>
      <th style="text-align: center">POS</th>
      <th style="text-align: center">ID</th>
      <th style="text-align: center">REF</th>
      <th style="text-align: center">ALT</th>
      <th style="text-align: center">QUAL</th>
      <th style="text-align: center">FILTER</th>
      <th style="text-align: center">INFO</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">321681</td>
      <td style="text-align: center">bnd</td>
      <td style="text-align: center">W</td>
      <td style="text-align: center">G</td>
      <td style="text-align: center">G]17:198982]</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">PASS</td>
      <td>SVTYPE=BND</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">321682</td>
      <td style="text-align: center">bnd</td>
      <td style="text-align: center">V</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">]13:123456]T</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">PASS</td>
      <td>SVTYPE=BND</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">123456</td>
      <td style="text-align: center">bnd</td>
      <td style="text-align: center">U</td>
      <td style="text-align: center">C</td>
      <td style="text-align: center">C[2:321682[</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">PASS</td>
      <td>SVTYPE=BND</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">123457</td>
      <td style="text-align: center">bnd</td>
      <td style="text-align: center">X</td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">[17:198983[A</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">PASS</td>
      <td>SVTYPE=BND</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">198982</td>
      <td style="text-align: center">bnd</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">A]2:321681]</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">PASS</td>
      <td>SVTYPE=BND</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">198983</td>
      <td style="text-align: center">bnd</td>
      <td style="text-align: center">Z</td>
      <td style="text-align: center">C</td>
      <td style="text-align: center">[13:123457[C</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">PASS</td>
      <td>SVTYPE=BND</td>
    </tr>
  </tbody>
</table>

<p>表头部分分别是：染色体号、变异起始位置、变异ID、参考基因组中的序列、变异的碱基、质量、过滤情况、INFO</p>

<p>第一条变异：G]17:198982] 表示该片段断裂后是左边片段，连接到17号染色体的198982号位置；与之配对的第5个变异，A]2:321681]表示17号染色体这个断裂后也是左边片段，所以与第一条变异的连接</p>

<p>第二条变异：]13:123456]T 表示该片段断裂后是右边片段，连接到13号染色体断裂后的左边片段；与之配对的第三条变异C[2:321682[表示该片段断裂后是左边片段，连接到2号染色体断裂后的右边片段</p>

<p>第四条变异：[17:198983[A表示该片段断裂后是右边片段，连接到17号染色体的198983位置；与之对应的第6个变异，[13:123457[C表示该片段断裂后是右边片段，连接到13号染色体的右边片段</p>

<p><img src="https://raw.githubusercontent.com/kunmonster/note_pic/main/note/20240902112306.png" alt="image.png" /></p>

<p>实际上还有其他情况</p>
<ul>
  <li>BND接着insertion</li>
  <li>Large Insertion</li>
  <li>Multiple mates</li>
  <li>et</li>
</ul>

<p>未完………………</p>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="bioinformatics" /><category term="sv" /><category term="vcf" /><summary type="html"><![CDATA[结构变异种类 INFO字段: SVTYPE]]></summary></entry><entry><title type="html">Linux 文本处理</title><link href="https://kunmonster.github.io//2023/09/29/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" rel="alternate" type="text/html" title="Linux 文本处理" /><published>2023-09-29T23:18:00+08:00</published><updated>2023-09-29T23:18:00+08:00</updated><id>https://kunmonster.github.io//2023/09/29/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86</id><content type="html" xml:base="https://kunmonster.github.io//2023/09/29/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"><![CDATA[<h3 id="正则表达式regular-expression">正则表达式(Regular Expression)</h3>
<hr />

<h4 id="基础正则basic-regular-expressionbasic-regex">基础正则(Basic Regular Expression—–Basic RegEx)</h4>

<p>元字符</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">字符</th>
      <th style="text-align: center">作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">前一个字符任意次</td>
    </tr>
    <tr>
      <td style="text-align: center">.</td>
      <td style="text-align: center">匹配除了换行符外的任意一个字符</td>
    </tr>
    <tr>
      <td style="text-align: center">^</td>
      <td style="text-align: center">匹配行首</td>
    </tr>
    <tr>
      <td style="text-align: center">$</td>
      <td style="text-align: center">匹配行尾</td>
    </tr>
    <tr>
      <td style="text-align: center">[ ]</td>
      <td style="text-align: center">匹配中括号中的任意一个</td>
    </tr>
    <tr>
      <td style="text-align: center">[^ ]</td>
      <td style="text-align: center">匹配中括号字符以外的任意一个字符—-相当于—–^[]的意思</td>
    </tr>
    <tr>
      <td style="text-align: center">{n}</td>
      <td style="text-align: center">表示前面的字符出现n次</td>
    </tr>
    <tr>
      <td style="text-align: center">{n,m}</td>
      <td style="text-align: center">前一字符最少出现n次最多出现m次</td>
    </tr>
    <tr>
      <td style="text-align: center">{n, }</td>
      <td style="text-align: center">前一字符最少出现n次</td>
    </tr>
    <tr>
      <td style="text-align: center">{ ,m}</td>
      <td style="text-align: center">前一字符最多出现m次</td>
    </tr>
    <tr>
      <td style="text-align: center">\</td>
      <td style="text-align: center">转义字符</td>
    </tr>
  </tbody>
</table>

<h4 id="扩展正则">扩展正则</h4>

<p>元字符</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">字符</th>
      <th style="text-align: center">功能</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">+</td>
      <td style="text-align: center">前面的字符重复一次或者一次以上</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">?</td>
      <td style="text-align: center">前面的字符重复一次或者0次</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">|</td>
      <td style="text-align: center">分支，注意这个符号实在表达式层面上运作，区别于[]运作于字符层面</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">( )</td>
      <td style="text-align: center">查找组</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">( )+</td>
      <td style="text-align: center">辨别多个重复组</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\数字</td>
      <td style="text-align: center">有多个分组时表明分组顺序，用对应顺序的分组来代替此序号</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">(:? 内容)</td>
      <td style="text-align: center">非捕获分组，使用序号时，不会计入序号中</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\w</td>
      <td style="text-align: center">pu查找字母、数字和下划线</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\w</td>
      <td style="text-align: center">匹配除字母、数字、下划线以外的字符（与上面的相反）</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\d</td>
      <td style="text-align: center">匹配数字,grep不支持</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\D</td>
      <td style="text-align: center">匹配数字以外的字符,grep不支持</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\s</td>
      <td style="text-align: center">匹配空白符</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">\S</td>
      <td style="text-align: center">匹配非空白符</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">xxx(?=条件)</td>
      <td style="text-align: center">正向先行断言,匹配xxx后面有指定字符的行</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">xxx(?!条件)</td>
      <td style="text-align: center">负向先行断言,匹配xxx后面没有指定字符的行</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">(?&lt;=条件)xxx</td>
      <td style="text-align: center">正向后行断言,匹配xxx前面有指定字符的行</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">(?&lt;!条件)xxx</td>
      <td style="text-align: center">负向后行断言,匹配xxx前面没有指定字符</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="grep">grep</h3>
<hr />
<p>命令格式</p>

<ul>
  <li>grep [option] [PATTERN] [FILE…]</li>
  <li>如果没有指定FILE那么对当前工作目录搜索</li>
</ul>

<p>常用选项</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">选项</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-E</td>
      <td style="text-align: center">此选项将使PATTERN支持扩展的正则—等价于—egrep</td>
    </tr>
    <tr>
      <td style="text-align: center">-F</td>
      <td style="text-align: center">将PATTERN理解成字符串而不是正则的表达式</td>
    </tr>
    <tr>
      <td style="text-align: center">-i</td>
      <td style="text-align: center">忽略大小写</td>
    </tr>
    <tr>
      <td style="text-align: center">-v</td>
      <td style="text-align: center">改变输出匹配行，转而输出非匹配行</td>
    </tr>
    <tr>
      <td style="text-align: center">-x</td>
      <td style="text-align: center">只需要整行匹配的行</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">统计输出结果的行</td>
    </tr>
    <tr>
      <td style="text-align: center">-o</td>
      <td style="text-align: center">只输出匹配的内容本身</td>
    </tr>
    <tr>
      <td style="text-align: center">-w</td>
      <td style="text-align: center">只匹配过滤的单词</td>
    </tr>
    <tr>
      <td style="text-align: center">-n</td>
      <td style="text-align: center">输出行号</td>
    </tr>
    <tr>
      <td style="text-align: center">-H</td>
      <td style="text-align: center">输出文件名:匹配内容</td>
    </tr>
    <tr>
      <td style="text-align: center">-A</td>
      <td style="text-align: center">显示匹配行的后面的行数</td>
    </tr>
    <tr>
      <td style="text-align: center">-B</td>
      <td style="text-align: center">before,显示匹配行前面的行数</td>
    </tr>
    <tr>
      <td style="text-align: center">-C</td>
      <td style="text-align: center">显示匹配行前面和后面的行数</td>
    </tr>
    <tr>
      <td style="text-align: center">–no-group-separator</td>
      <td style="text-align: center">使用前面的-A,B,C会在两个匹配行之间使用分隔行，此选项可以取消</td>
    </tr>
    <tr>
      <td style="text-align: center">–group-separator</td>
      <td style="text-align: center">=’xxxx’指定分隔符号</td>
    </tr>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">递归grep,此时不用指定文件</td>
    </tr>
    <tr>
      <td style="text-align: center">-l</td>
      <td style="text-align: center">只打印文件名，不打印匹配内容</td>
    </tr>
    <tr>
      <td style="text-align: center">-R</td>
      <td style="text-align: center">递归但是不输出符号链接和文件内容</td>
    </tr>
    <tr>
      <td style="text-align: center">-L</td>
      <td style="text-align: center">只打印没被选中行的文件名称</td>
    </tr>
    <tr>
      <td style="text-align: center">-z</td>
      <td style="text-align: center">数据行以0（NULL）结尾而不是换行符</td>
    </tr>
    <tr>
      <td style="text-align: center">-Z</td>
      <td style="text-align: center">在文件名后面打印null</td>
    </tr>
    <tr>
      <td style="text-align: center">–include=GLOB</td>
      <td style="text-align: center">只查找匹配 GLOB（含通配符的文件模式）的文件</td>
    </tr>
    <tr>
      <td style="text-align: center">–exclude=GLOB</td>
      <td style="text-align: center">跳过匹配 GLOB 的文件</td>
    </tr>
    <tr>
      <td style="text-align: center">–exclude-dir=GLOB</td>
      <td style="text-align: center">在进行递归匹配的时候排除的文件夹，用多次参数指定多个目录</td>
    </tr>
    <tr>
      <td style="text-align: center">-d 动作, –directories=动作</td>
      <td style="text-align: center">处理目录的方式:<动作> 可以是 "read"、"recurse" 或 "skip",<动作> 可以是 "read" 或 "ski,</动作></动作></td>
    </tr>
    <tr>
      <td style="text-align: center">-b</td>
      <td style="text-align: center">输出结果的同时打印字节偏移量</td>
    </tr>
  </tbody>
</table>

<h3 id="sed">sed</h3>
<hr />

<p>操作、过滤和转换文本的强大工具</p>

<ul>
  <li>一次读取一行，放入sed工作车间（模式车间，文本数据读入内存）</li>
  <li>模式匹配
    <ul>
      <li>匹配失败（默认输出到屏幕）</li>
      <li>匹配成功（编辑，输出到屏幕）</li>
    </ul>
  </li>
</ul>

<p>语法</p>

<ul>
  <li>sed [ 选项 ]   [ sed内置命令字符 ]  [ 输入文件 ]</li>
  <li>注意内置命令字符需要单引号括起来</li>
  <li>内置命令中顺序为
    <ul>
      <li>[ 范围命令]</li>
      <li>注意范围与命令之间，命令与命令之间无需分隔</li>
    </ul>
  </li>
</ul>

<p>选项</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">参数</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-n</td>
      <td style="text-align: center">取消默认sed的输出,常与内置命令p一起使用</td>
    </tr>
    <tr>
      <td style="text-align: center">-i</td>
      <td style="text-align: center">直接将修改结果写入文件,不用-i,sed修改的是内存数据</td>
    </tr>
    <tr>
      <td style="text-align: center">-e</td>
      <td style="text-align: center">多次编辑,不需要再管管道符,一个命令脚本一个-e</td>
    </tr>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">支持扩展正则</td>
    </tr>
  </tbody>
</table>

<p>内置命令</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">命令</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">s/正则/替换内容/g</td>
      <td style="text-align: center">匹配正则内容并替换（支持正则）,结尾g表示全局匹配，将小写转换为大写s/[aeiou]/\u&amp;/g或者y/aeiou/AEIOU/</td>
    </tr>
    <tr>
      <td style="text-align: center">a</td>
      <td style="text-align: center">append,对文本追加,在指定行后面添加一行或者多行文本(可以使用换行符)</td>
    </tr>
    <tr>
      <td style="text-align: center">d</td>
      <td style="text-align: center">Delete,删除匹配行</td>
    </tr>
    <tr>
      <td style="text-align: center">i</td>
      <td style="text-align: center">insert,表示插入文本,在指定行前添加一行/多行文本</td>
    </tr>
    <tr>
      <td style="text-align: center">p</td>
      <td style="text-align: center">print,打印匹配行的内容,通常与-n一起使用</td>
    </tr>
    <tr>
      <td style="text-align: center">s/正则/替换内容/g</td>
      <td style="text-align: center">匹配正则内容并替换（支持正则）,结尾g表示全局匹配</td>
    </tr>
    <tr>
      <td style="text-align: center">Q</td>
      <td style="text-align: center">sed立即退出，不再处理，之前的将输出</td>
    </tr>
    <tr>
      <td style="text-align: center">N</td>
      <td style="text-align: center">读取下一行并加入模式空间，即模式空间拥有当前行和下一行</td>
    </tr>
    <tr>
      <td style="text-align: center">P</td>
      <td style="text-align: center">打印模式空间第一行，当前行</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">删除模式空间第一行，并循环处理剩余部分，如果模式空间为空，则读取下一行</td>
    </tr>
  </tbody>
</table>

<p>sed匹配范围</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">范围</th>
      <th style="text-align: center">解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">空地址(不加数字)</td>
      <td style="text-align: center">全文处理</td>
    </tr>
    <tr>
      <td style="text-align: center">单地址(一个数字)</td>
      <td style="text-align: center">指定文件的某一行</td>
    </tr>
    <tr>
      <td style="text-align: center">/pattern/</td>
      <td style="text-align: center">被模式匹配到的每一行，如果不表示范围的话，在两个正则表达式之间需要分号隔开</td>
    </tr>
    <tr>
      <td style="text-align: center">范围区间</td>
      <td style="text-align: center">10,20 10到20行;10,+5第10行向下5行,/pattern1/, /pattern2/; ‘n,4’表示第n行到结尾,包括第n行</td>
    </tr>
    <tr>
      <td style="text-align: center">步长</td>
      <td style="text-align: center">1~2,表示1、3、5、7、9行,2~2表示2、4、5、6、8、10偶数行</td>
    </tr>
  </tbody>
</table>

<p>注意</p>
<ul>
  <li>在sed中，单引号和双引号有所不同,如果要在pattern,command中使用变量，那么最好使用双引号，如果不用变量可以使用单引号</li>
</ul>

<h3 id="awk">awk</h3>
<hr />
<p>更适合编辑、处理匹配到的文本内容</p>

<p>使用语法</p>
<ul>
  <li>awk [ option ] ‘pattern[action]’ file …</li>
  <li>awk 参数 ‘条件动作’ 文件</li>
  <li>awk options ‘pattern {action}’ file</li>
  <li>参数中的模式代表，条件或者正则等模式，条件包括对行限定等</li>
</ul>

<p>内置变量</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">形式</th>
      <th style="text-align: center">解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">$n</td>
      <td style="text-align: center">指定分隔符后,当前记录的第n个字段</td>
    </tr>
    <tr>
      <td style="text-align: center">$0</td>
      <td style="text-align: center">完整的输入记录，整行</td>
    </tr>
    <tr>
      <td style="text-align: center">FS</td>
      <td style="text-align: center">字段分隔符,默认是空格</td>
    </tr>
    <tr>
      <td style="text-align: center">NF(number of fields )</td>
      <td style="text-align: center">分割后,当前行一共有多少个字段</td>
    </tr>
    <tr>
      <td style="text-align: center">NR ( Number of records)</td>
      <td style="text-align: center">当前记录数,行数</td>
    </tr>
  </tbody>
</table>

<p>注意</p>
<ul>
  <li>使用-F “ ”指定分隔符时，可以使用”[多个分隔符]”方括号来使用多个分隔符</li>
</ul>]]></content><author><name>Feng kunjiang</name><email>fkj_monster@163.com</email></author><category term="Linux" /><category term="Text" /><summary type="html"><![CDATA[正则表达式(Regular Expression)]]></summary></entry></feed>